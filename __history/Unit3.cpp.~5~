//---------------------------------------------------------------------------

#include <fmx.h>
#pragma hdrstop

#include "Unit1.h"
#include "Unit3.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.fmx"
TForm3 *Form3;
//---------------------------------------------------------------------------
__fastcall TForm3::TForm3(TComponent* Owner)
	: TForm(Owner)
{
}
//---------------------------------------------------------------------------

void __fastcall TForm3::FormActivate(TObject *Sender)
{
/*
double Аa =1;
double Аb=2;
double Аc=3;
double Аd=4;
Series1->Clear();
Series1->Add(Аa,"Цех 1",4);
Series1->Add(Аb,"Цех 2",3);
Series1->Add(Аc,"Цех 3",2);
Series1->Add(Аd,"Цех 4",1);

Series2->Clear();
Series3->Clear();
for (int i = 0; i <= 100; i++)
{
Series2->AddXY(0.02*Pi*i,sin(0.02*Pi*i),"", 51);
Series3->AddXY(0.02*Pi*i,cos(0.02*Pi*i),"",61);
}
*/
/*
    const Pi=3.14159;

    	int n_rasp=5; // koli4estvo ya4eek raspredeleniya
    	//int n=288000; //kol-vo elementov massiva

    	short a,b, *m, max, min, deltay;
    	unsigned int *rasp;	//,n_rasp;
    	short count;

    	max=Form1->Buffer[0];
    	min=Form1->Buffer[0];

    	for(int i = 0 ; i < Form1->Buffer.size() ; i++)
    	{
    		if (Form1->Buffer[i]>max) max=Form1->Buffer[i];
    		if (Form1->Buffer[i]<min) min=Form1->Buffer[i];
    	}

    	//quickSortR(buf, lbuf);

    	deltay=(unsigned short)((max-min)/n_rasp+1);

    	rasp = (unsigned int *)(malloc(n_rasp*sizeof(unsigned int)));

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    	for (int i = 0; i < Form1->Buffer.size(); i++)
    	{
    		count=min;
    		for (int j=0; j<n_rasp; j++)
    		{
    			if ((Form1->Buffer[i] >=count) && (Form1->Buffer[i]<=count+deltay))
    			{
    				rasp[j]++;
    				break;
    			}
    		count=count+deltay;
    		}
    	}

    //*******************************************************************

    	float math_f=0;
    	long double dispers=0;
    	unsigned int summall=0;

    	for (int i=0; i<n_rasp; i++)
    	{
    		summall=rasp[i]+summall;
    		math_f+=rasp[i]*i;
    	}
    	printf("Математическое ожидание = %3.5f\n",math_f);


    	for (int i=0; i<n_rasp; i++)
    	{
    		dispers+=((long double)(i)-math_f)*((long double)(i)-math_f)*(rasp[i]);
    	}
    	dispers=dispers/summall;

    long double gausse=0;
    int dat,control_rasp=0;
    dat=min;


    Form1->gaussBuffer.resize(n_rasp);

    for (int i=0;i<n_rasp;i++)
    {
    	control_rasp=rasp[i]+control_rasp;
    	Form1->gaussBuffer[i]=(long double)summall*exp(-((i-math_f)*(i-math_f))/(2*dispers))/(sqrt(2*3.14159265*dispers));
    	dat=dat+deltay;
    }


    dat=min;
    for (int i = 0; i <= n_rasp; i++)
    {
    //Series1->AddXY(dat, 0);
    //Series2->AddXY(rasp[i], 0);
    //Series3->AddXY(Form1->gaussBuffer[i],0);
    dat=dat+deltay;
	}

	map <int, int>::iterator cur;
	map <int, double>::iterator cur2;
	int sizeBuf;
	float prob;
	int index;
	double math_o, math_o_pow;
	double disp;
	double stDev;

	sizeBuf = Buffer.size();
	prob = 0;
	math_o = math_o_pow = 0;
	disp = 0;
	stDev = 0;

	for(int i=0; i<sizeBuf; i++)	//частота попаданий символов в бф.
	{
		raspMap[(int)Buffer[i]]++;
	}

	for(cur=raspMap.begin(); cur!=raspMap.end(); cur++)	//вероятность попаданий символов в бф.
	{
		prob = (float)(*cur).second / sizeBuf;
		probMap[(*cur).first] = prob;
	}

	for (cur2=probMap.begin(); cur2!=probMap.end(); cur2++)	//мат. ожидание
	{
		math_o = math_o + (*cur2).first * (*cur2).second;
	}

	for (cur2=probMap.begin(); cur2!=probMap.end(); cur2++)
	{
		index = pow((*cur2).first,2);
		probMapPow[index] = (*cur2).second;
	}

	for (cur2=probMapPow.begin(); cur2!=probMapPow.end(); cur2++)	//мат. ожидание x(2)
	{
		math_o_pow = math_o_pow + (*cur2).first * (*cur2).second;
	}

	disp = math_o_pow - pow(math_o, 2);		//дисперсия

	stDev = sqrt(disp);                     //cреднеквадратическое отклонение

	Form3->Series1->Clear();
	for(cur2=probMap.begin(); cur2!=probMap.end(); cur2++)
	{
		Form3->Series1->AddXY((*cur2).first, (*cur2).second, "", 10);
	}

*/
}
//---------------------------------------------------------------------------

